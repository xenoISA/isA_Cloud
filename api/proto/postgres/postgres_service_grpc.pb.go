// postgres_service.proto - PostgreSQL Database gRPC Service
// Direct PostgreSQL access with connection pooling and concurrent processing
// Pure relational database operations - vectors handled by Qdrant service

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: postgres_service.proto

package postgres

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PostgresService_Query_FullMethodName                = "/isa.postgres.PostgresService/Query"
	PostgresService_QueryRow_FullMethodName             = "/isa.postgres.PostgresService/QueryRow"
	PostgresService_Execute_FullMethodName              = "/isa.postgres.PostgresService/Execute"
	PostgresService_ExecuteBatch_FullMethodName         = "/isa.postgres.PostgresService/ExecuteBatch"
	PostgresService_SelectFrom_FullMethodName           = "/isa.postgres.PostgresService/SelectFrom"
	PostgresService_InsertInto_FullMethodName           = "/isa.postgres.PostgresService/InsertInto"
	PostgresService_UpdateTable_FullMethodName          = "/isa.postgres.PostgresService/UpdateTable"
	PostgresService_DeleteFrom_FullMethodName           = "/isa.postgres.PostgresService/DeleteFrom"
	PostgresService_BeginTransaction_FullMethodName     = "/isa.postgres.PostgresService/BeginTransaction"
	PostgresService_CommitTransaction_FullMethodName    = "/isa.postgres.PostgresService/CommitTransaction"
	PostgresService_RollbackTransaction_FullMethodName  = "/isa.postgres.PostgresService/RollbackTransaction"
	PostgresService_ExecuteInTransaction_FullMethodName = "/isa.postgres.PostgresService/ExecuteInTransaction"
	PostgresService_GetTableInfo_FullMethodName         = "/isa.postgres.PostgresService/GetTableInfo"
	PostgresService_ListTables_FullMethodName           = "/isa.postgres.PostgresService/ListTables"
	PostgresService_TableExists_FullMethodName          = "/isa.postgres.PostgresService/TableExists"
	PostgresService_HealthCheck_FullMethodName          = "/isa.postgres.PostgresService/HealthCheck"
	PostgresService_GetStats_FullMethodName             = "/isa.postgres.PostgresService/GetStats"
)

// PostgresServiceClient is the client API for PostgresService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PostgresServiceClient interface {
	// Query - Execute SELECT query
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
	// QueryRow - Execute SELECT and return single row
	QueryRow(ctx context.Context, in *QueryRowRequest, opts ...grpc.CallOption) (*QueryRowResponse, error)
	// Execute - Execute INSERT/UPDATE/DELETE
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	// ExecuteBatch - Execute multiple operations in batch
	ExecuteBatch(ctx context.Context, in *ExecuteBatchRequest, opts ...grpc.CallOption) (*ExecuteBatchResponse, error)
	// SelectFrom - Query builder style SELECT
	SelectFrom(ctx context.Context, in *SelectFromRequest, opts ...grpc.CallOption) (*SelectFromResponse, error)
	// InsertInto - Insert rows into table
	InsertInto(ctx context.Context, in *InsertIntoRequest, opts ...grpc.CallOption) (*InsertIntoResponse, error)
	// UpdateTable - Update rows in table
	UpdateTable(ctx context.Context, in *UpdateTableRequest, opts ...grpc.CallOption) (*UpdateTableResponse, error)
	// DeleteFrom - Delete rows from table
	DeleteFrom(ctx context.Context, in *DeleteFromRequest, opts ...grpc.CallOption) (*DeleteFromResponse, error)
	// BeginTransaction - Start a new transaction
	BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*BeginTransactionResponse, error)
	// CommitTransaction - Commit transaction
	CommitTransaction(ctx context.Context, in *CommitTransactionRequest, opts ...grpc.CallOption) (*CommitTransactionResponse, error)
	// RollbackTransaction - Rollback transaction
	RollbackTransaction(ctx context.Context, in *RollbackTransactionRequest, opts ...grpc.CallOption) (*RollbackTransactionResponse, error)
	// ExecuteInTransaction - Execute operations within a transaction
	ExecuteInTransaction(ctx context.Context, in *ExecuteInTransactionRequest, opts ...grpc.CallOption) (*ExecuteInTransactionResponse, error)
	// GetTableInfo - Get table schema information
	GetTableInfo(ctx context.Context, in *GetTableInfoRequest, opts ...grpc.CallOption) (*GetTableInfoResponse, error)
	// ListTables - List all tables in schema
	ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (*ListTablesResponse, error)
	// TableExists - Check if table exists
	TableExists(ctx context.Context, in *TableExistsRequest, opts ...grpc.CallOption) (*TableExistsResponse, error)
	// HealthCheck - Service health check
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// GetStats - Get connection pool and database statistics
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsResponse, error)
}

type postgresServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPostgresServiceClient(cc grpc.ClientConnInterface) PostgresServiceClient {
	return &postgresServiceClient{cc}
}

func (c *postgresServiceClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, PostgresService_Query_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) QueryRow(ctx context.Context, in *QueryRowRequest, opts ...grpc.CallOption) (*QueryRowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRowResponse)
	err := c.cc.Invoke(ctx, PostgresService_QueryRow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, PostgresService_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) ExecuteBatch(ctx context.Context, in *ExecuteBatchRequest, opts ...grpc.CallOption) (*ExecuteBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteBatchResponse)
	err := c.cc.Invoke(ctx, PostgresService_ExecuteBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) SelectFrom(ctx context.Context, in *SelectFromRequest, opts ...grpc.CallOption) (*SelectFromResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SelectFromResponse)
	err := c.cc.Invoke(ctx, PostgresService_SelectFrom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) InsertInto(ctx context.Context, in *InsertIntoRequest, opts ...grpc.CallOption) (*InsertIntoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertIntoResponse)
	err := c.cc.Invoke(ctx, PostgresService_InsertInto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) UpdateTable(ctx context.Context, in *UpdateTableRequest, opts ...grpc.CallOption) (*UpdateTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTableResponse)
	err := c.cc.Invoke(ctx, PostgresService_UpdateTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) DeleteFrom(ctx context.Context, in *DeleteFromRequest, opts ...grpc.CallOption) (*DeleteFromResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFromResponse)
	err := c.cc.Invoke(ctx, PostgresService_DeleteFrom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*BeginTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BeginTransactionResponse)
	err := c.cc.Invoke(ctx, PostgresService_BeginTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) CommitTransaction(ctx context.Context, in *CommitTransactionRequest, opts ...grpc.CallOption) (*CommitTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitTransactionResponse)
	err := c.cc.Invoke(ctx, PostgresService_CommitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) RollbackTransaction(ctx context.Context, in *RollbackTransactionRequest, opts ...grpc.CallOption) (*RollbackTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RollbackTransactionResponse)
	err := c.cc.Invoke(ctx, PostgresService_RollbackTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) ExecuteInTransaction(ctx context.Context, in *ExecuteInTransactionRequest, opts ...grpc.CallOption) (*ExecuteInTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteInTransactionResponse)
	err := c.cc.Invoke(ctx, PostgresService_ExecuteInTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) GetTableInfo(ctx context.Context, in *GetTableInfoRequest, opts ...grpc.CallOption) (*GetTableInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTableInfoResponse)
	err := c.cc.Invoke(ctx, PostgresService_GetTableInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (*ListTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTablesResponse)
	err := c.cc.Invoke(ctx, PostgresService_ListTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) TableExists(ctx context.Context, in *TableExistsRequest, opts ...grpc.CallOption) (*TableExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TableExistsResponse)
	err := c.cc.Invoke(ctx, PostgresService_TableExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, PostgresService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postgresServiceClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatsResponse)
	err := c.cc.Invoke(ctx, PostgresService_GetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PostgresServiceServer is the server API for PostgresService service.
// All implementations must embed UnimplementedPostgresServiceServer
// for forward compatibility.
type PostgresServiceServer interface {
	// Query - Execute SELECT query
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	// QueryRow - Execute SELECT and return single row
	QueryRow(context.Context, *QueryRowRequest) (*QueryRowResponse, error)
	// Execute - Execute INSERT/UPDATE/DELETE
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
	// ExecuteBatch - Execute multiple operations in batch
	ExecuteBatch(context.Context, *ExecuteBatchRequest) (*ExecuteBatchResponse, error)
	// SelectFrom - Query builder style SELECT
	SelectFrom(context.Context, *SelectFromRequest) (*SelectFromResponse, error)
	// InsertInto - Insert rows into table
	InsertInto(context.Context, *InsertIntoRequest) (*InsertIntoResponse, error)
	// UpdateTable - Update rows in table
	UpdateTable(context.Context, *UpdateTableRequest) (*UpdateTableResponse, error)
	// DeleteFrom - Delete rows from table
	DeleteFrom(context.Context, *DeleteFromRequest) (*DeleteFromResponse, error)
	// BeginTransaction - Start a new transaction
	BeginTransaction(context.Context, *BeginTransactionRequest) (*BeginTransactionResponse, error)
	// CommitTransaction - Commit transaction
	CommitTransaction(context.Context, *CommitTransactionRequest) (*CommitTransactionResponse, error)
	// RollbackTransaction - Rollback transaction
	RollbackTransaction(context.Context, *RollbackTransactionRequest) (*RollbackTransactionResponse, error)
	// ExecuteInTransaction - Execute operations within a transaction
	ExecuteInTransaction(context.Context, *ExecuteInTransactionRequest) (*ExecuteInTransactionResponse, error)
	// GetTableInfo - Get table schema information
	GetTableInfo(context.Context, *GetTableInfoRequest) (*GetTableInfoResponse, error)
	// ListTables - List all tables in schema
	ListTables(context.Context, *ListTablesRequest) (*ListTablesResponse, error)
	// TableExists - Check if table exists
	TableExists(context.Context, *TableExistsRequest) (*TableExistsResponse, error)
	// HealthCheck - Service health check
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// GetStats - Get connection pool and database statistics
	GetStats(context.Context, *GetStatsRequest) (*GetStatsResponse, error)
	mustEmbedUnimplementedPostgresServiceServer()
}

// UnimplementedPostgresServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPostgresServiceServer struct{}

func (UnimplementedPostgresServiceServer) Query(context.Context, *QueryRequest) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedPostgresServiceServer) QueryRow(context.Context, *QueryRowRequest) (*QueryRowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRow not implemented")
}
func (UnimplementedPostgresServiceServer) Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedPostgresServiceServer) ExecuteBatch(context.Context, *ExecuteBatchRequest) (*ExecuteBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBatch not implemented")
}
func (UnimplementedPostgresServiceServer) SelectFrom(context.Context, *SelectFromRequest) (*SelectFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectFrom not implemented")
}
func (UnimplementedPostgresServiceServer) InsertInto(context.Context, *InsertIntoRequest) (*InsertIntoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertInto not implemented")
}
func (UnimplementedPostgresServiceServer) UpdateTable(context.Context, *UpdateTableRequest) (*UpdateTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTable not implemented")
}
func (UnimplementedPostgresServiceServer) DeleteFrom(context.Context, *DeleteFromRequest) (*DeleteFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFrom not implemented")
}
func (UnimplementedPostgresServiceServer) BeginTransaction(context.Context, *BeginTransactionRequest) (*BeginTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginTransaction not implemented")
}
func (UnimplementedPostgresServiceServer) CommitTransaction(context.Context, *CommitTransactionRequest) (*CommitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (UnimplementedPostgresServiceServer) RollbackTransaction(context.Context, *RollbackTransactionRequest) (*RollbackTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackTransaction not implemented")
}
func (UnimplementedPostgresServiceServer) ExecuteInTransaction(context.Context, *ExecuteInTransactionRequest) (*ExecuteInTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteInTransaction not implemented")
}
func (UnimplementedPostgresServiceServer) GetTableInfo(context.Context, *GetTableInfoRequest) (*GetTableInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTableInfo not implemented")
}
func (UnimplementedPostgresServiceServer) ListTables(context.Context, *ListTablesRequest) (*ListTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTables not implemented")
}
func (UnimplementedPostgresServiceServer) TableExists(context.Context, *TableExistsRequest) (*TableExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableExists not implemented")
}
func (UnimplementedPostgresServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedPostgresServiceServer) GetStats(context.Context, *GetStatsRequest) (*GetStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedPostgresServiceServer) mustEmbedUnimplementedPostgresServiceServer() {}
func (UnimplementedPostgresServiceServer) testEmbeddedByValue()                         {}

// UnsafePostgresServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PostgresServiceServer will
// result in compilation errors.
type UnsafePostgresServiceServer interface {
	mustEmbedUnimplementedPostgresServiceServer()
}

func RegisterPostgresServiceServer(s grpc.ServiceRegistrar, srv PostgresServiceServer) {
	// If the following call pancis, it indicates UnimplementedPostgresServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PostgresService_ServiceDesc, srv)
}

func _PostgresService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_QueryRow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).QueryRow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_QueryRow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).QueryRow(ctx, req.(*QueryRowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_ExecuteBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).ExecuteBatch(ctx, req.(*ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_SelectFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectFromRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).SelectFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_SelectFrom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).SelectFrom(ctx, req.(*SelectFromRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_InsertInto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertIntoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).InsertInto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_InsertInto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).InsertInto(ctx, req.(*InsertIntoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_UpdateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).UpdateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_UpdateTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).UpdateTable(ctx, req.(*UpdateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_DeleteFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFromRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).DeleteFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_DeleteFrom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).DeleteFrom(ctx, req.(*DeleteFromRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_BeginTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).BeginTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_BeginTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).BeginTransaction(ctx, req.(*BeginTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_CommitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).CommitTransaction(ctx, req.(*CommitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_RollbackTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).RollbackTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_RollbackTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).RollbackTransaction(ctx, req.(*RollbackTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_ExecuteInTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteInTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).ExecuteInTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_ExecuteInTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).ExecuteInTransaction(ctx, req.(*ExecuteInTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_GetTableInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).GetTableInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_GetTableInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).GetTableInfo(ctx, req.(*GetTableInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_ListTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).ListTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_ListTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).ListTables(ctx, req.(*ListTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_TableExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).TableExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_TableExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).TableExists(ctx, req.(*TableExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostgresService_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostgresServiceServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostgresService_GetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostgresServiceServer).GetStats(ctx, req.(*GetStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PostgresService_ServiceDesc is the grpc.ServiceDesc for PostgresService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PostgresService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "isa.postgres.PostgresService",
	HandlerType: (*PostgresServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _PostgresService_Query_Handler,
		},
		{
			MethodName: "QueryRow",
			Handler:    _PostgresService_QueryRow_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _PostgresService_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _PostgresService_ExecuteBatch_Handler,
		},
		{
			MethodName: "SelectFrom",
			Handler:    _PostgresService_SelectFrom_Handler,
		},
		{
			MethodName: "InsertInto",
			Handler:    _PostgresService_InsertInto_Handler,
		},
		{
			MethodName: "UpdateTable",
			Handler:    _PostgresService_UpdateTable_Handler,
		},
		{
			MethodName: "DeleteFrom",
			Handler:    _PostgresService_DeleteFrom_Handler,
		},
		{
			MethodName: "BeginTransaction",
			Handler:    _PostgresService_BeginTransaction_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _PostgresService_CommitTransaction_Handler,
		},
		{
			MethodName: "RollbackTransaction",
			Handler:    _PostgresService_RollbackTransaction_Handler,
		},
		{
			MethodName: "ExecuteInTransaction",
			Handler:    _PostgresService_ExecuteInTransaction_Handler,
		},
		{
			MethodName: "GetTableInfo",
			Handler:    _PostgresService_GetTableInfo_Handler,
		},
		{
			MethodName: "ListTables",
			Handler:    _PostgresService_ListTables_Handler,
		},
		{
			MethodName: "TableExists",
			Handler:    _PostgresService_TableExists_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _PostgresService_HealthCheck_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _PostgresService_GetStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "postgres_service.proto",
}
