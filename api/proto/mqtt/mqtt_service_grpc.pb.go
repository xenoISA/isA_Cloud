// mqtt_service.proto - MQTT 消息代理服务 gRPC 接口
// 提供统一的 MQTT 消息发布/订阅接口，支持多租户和设备管理

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: mqtt_service.proto

package mqtt

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MQTTService_Connect_FullMethodName               = "/isa.mqtt.MQTTService/Connect"
	MQTTService_Disconnect_FullMethodName            = "/isa.mqtt.MQTTService/Disconnect"
	MQTTService_GetConnectionStatus_FullMethodName   = "/isa.mqtt.MQTTService/GetConnectionStatus"
	MQTTService_Publish_FullMethodName               = "/isa.mqtt.MQTTService/Publish"
	MQTTService_PublishBatch_FullMethodName          = "/isa.mqtt.MQTTService/PublishBatch"
	MQTTService_PublishJSON_FullMethodName           = "/isa.mqtt.MQTTService/PublishJSON"
	MQTTService_Subscribe_FullMethodName             = "/isa.mqtt.MQTTService/Subscribe"
	MQTTService_SubscribeMultiple_FullMethodName     = "/isa.mqtt.MQTTService/SubscribeMultiple"
	MQTTService_Unsubscribe_FullMethodName           = "/isa.mqtt.MQTTService/Unsubscribe"
	MQTTService_ListSubscriptions_FullMethodName     = "/isa.mqtt.MQTTService/ListSubscriptions"
	MQTTService_RegisterDevice_FullMethodName        = "/isa.mqtt.MQTTService/RegisterDevice"
	MQTTService_UnregisterDevice_FullMethodName      = "/isa.mqtt.MQTTService/UnregisterDevice"
	MQTTService_ListDevices_FullMethodName           = "/isa.mqtt.MQTTService/ListDevices"
	MQTTService_GetDeviceInfo_FullMethodName         = "/isa.mqtt.MQTTService/GetDeviceInfo"
	MQTTService_UpdateDeviceStatus_FullMethodName    = "/isa.mqtt.MQTTService/UpdateDeviceStatus"
	MQTTService_GetTopicInfo_FullMethodName          = "/isa.mqtt.MQTTService/GetTopicInfo"
	MQTTService_ListTopics_FullMethodName            = "/isa.mqtt.MQTTService/ListTopics"
	MQTTService_ValidateTopic_FullMethodName         = "/isa.mqtt.MQTTService/ValidateTopic"
	MQTTService_SetRetainedMessage_FullMethodName    = "/isa.mqtt.MQTTService/SetRetainedMessage"
	MQTTService_GetRetainedMessage_FullMethodName    = "/isa.mqtt.MQTTService/GetRetainedMessage"
	MQTTService_DeleteRetainedMessage_FullMethodName = "/isa.mqtt.MQTTService/DeleteRetainedMessage"
	MQTTService_GetStatistics_FullMethodName         = "/isa.mqtt.MQTTService/GetStatistics"
	MQTTService_GetDeviceMetrics_FullMethodName      = "/isa.mqtt.MQTTService/GetDeviceMetrics"
	MQTTService_HealthCheck_FullMethodName           = "/isa.mqtt.MQTTService/HealthCheck"
)

// MQTTServiceClient is the client API for MQTTService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MQTTServiceClient interface {
	// ========== 连接管理 ==========
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	GetConnectionStatus(ctx context.Context, in *ConnectionStatusRequest, opts ...grpc.CallOption) (*ConnectionStatusResponse, error)
	// ========== 消息发布 ==========
	// 发布单条消息
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// 批量发布消息
	PublishBatch(ctx context.Context, in *PublishBatchRequest, opts ...grpc.CallOption) (*PublishBatchResponse, error)
	// 发布 JSON 消息（自动序列化）
	PublishJSON(ctx context.Context, in *PublishJSONRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// ========== 消息订阅 ==========
	// 订阅主题（流式接收消息）
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageResponse], error)
	// 批量订阅多个主题
	SubscribeMultiple(ctx context.Context, in *SubscribeMultipleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageResponse], error)
	// 取消订阅
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// 获取订阅列表
	ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error)
	// ========== 设备管理 ==========
	RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error)
	UnregisterDevice(ctx context.Context, in *UnregisterDeviceRequest, opts ...grpc.CallOption) (*UnregisterDeviceResponse, error)
	ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error)
	GetDeviceInfo(ctx context.Context, in *GetDeviceInfoRequest, opts ...grpc.CallOption) (*GetDeviceInfoResponse, error)
	UpdateDeviceStatus(ctx context.Context, in *UpdateDeviceStatusRequest, opts ...grpc.CallOption) (*UpdateDeviceStatusResponse, error)
	// ========== 主题管理 ==========
	GetTopicInfo(ctx context.Context, in *GetTopicInfoRequest, opts ...grpc.CallOption) (*GetTopicInfoResponse, error)
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	ValidateTopic(ctx context.Context, in *ValidateTopicRequest, opts ...grpc.CallOption) (*ValidateTopicResponse, error)
	// ========== 保留消息 ==========
	SetRetainedMessage(ctx context.Context, in *SetRetainedMessageRequest, opts ...grpc.CallOption) (*SetRetainedMessageResponse, error)
	GetRetainedMessage(ctx context.Context, in *GetRetainedMessageRequest, opts ...grpc.CallOption) (*GetRetainedMessageResponse, error)
	DeleteRetainedMessage(ctx context.Context, in *DeleteRetainedMessageRequest, opts ...grpc.CallOption) (*DeleteRetainedMessageResponse, error)
	// ========== 统计和监控 ==========
	GetStatistics(ctx context.Context, in *GetStatisticsRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error)
	GetDeviceMetrics(ctx context.Context, in *GetDeviceMetricsRequest, opts ...grpc.CallOption) (*GetDeviceMetricsResponse, error)
	// ========== 健康检查 ==========
	HealthCheck(ctx context.Context, in *MQTTHealthCheckRequest, opts ...grpc.CallOption) (*MQTTHealthCheckResponse, error)
}

type mQTTServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMQTTServiceClient(cc grpc.ClientConnInterface) MQTTServiceClient {
	return &mQTTServiceClient{cc}
}

func (c *mQTTServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, MQTTService_Connect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectResponse)
	err := c.cc.Invoke(ctx, MQTTService_Disconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetConnectionStatus(ctx context.Context, in *ConnectionStatusRequest, opts ...grpc.CallOption) (*ConnectionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectionStatusResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetConnectionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, MQTTService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) PublishBatch(ctx context.Context, in *PublishBatchRequest, opts ...grpc.CallOption) (*PublishBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishBatchResponse)
	err := c.cc.Invoke(ctx, MQTTService_PublishBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) PublishJSON(ctx context.Context, in *PublishJSONRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, MQTTService_PublishJSON_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MQTTService_ServiceDesc.Streams[0], MQTTService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, MessageResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MQTTService_SubscribeClient = grpc.ServerStreamingClient[MessageResponse]

func (c *mQTTServiceClient) SubscribeMultiple(ctx context.Context, in *SubscribeMultipleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MQTTService_ServiceDesc.Streams[1], MQTTService_SubscribeMultiple_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeMultipleRequest, MessageResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MQTTService_SubscribeMultipleClient = grpc.ServerStreamingClient[MessageResponse]

func (c *mQTTServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, MQTTService_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubscriptionsResponse)
	err := c.cc.Invoke(ctx, MQTTService_ListSubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterDeviceResponse)
	err := c.cc.Invoke(ctx, MQTTService_RegisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) UnregisterDevice(ctx context.Context, in *UnregisterDeviceRequest, opts ...grpc.CallOption) (*UnregisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterDeviceResponse)
	err := c.cc.Invoke(ctx, MQTTService_UnregisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDevicesResponse)
	err := c.cc.Invoke(ctx, MQTTService_ListDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetDeviceInfo(ctx context.Context, in *GetDeviceInfoRequest, opts ...grpc.CallOption) (*GetDeviceInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeviceInfoResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetDeviceInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) UpdateDeviceStatus(ctx context.Context, in *UpdateDeviceStatusRequest, opts ...grpc.CallOption) (*UpdateDeviceStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDeviceStatusResponse)
	err := c.cc.Invoke(ctx, MQTTService_UpdateDeviceStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetTopicInfo(ctx context.Context, in *GetTopicInfoRequest, opts ...grpc.CallOption) (*GetTopicInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicInfoResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetTopicInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, MQTTService_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) ValidateTopic(ctx context.Context, in *ValidateTopicRequest, opts ...grpc.CallOption) (*ValidateTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTopicResponse)
	err := c.cc.Invoke(ctx, MQTTService_ValidateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) SetRetainedMessage(ctx context.Context, in *SetRetainedMessageRequest, opts ...grpc.CallOption) (*SetRetainedMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRetainedMessageResponse)
	err := c.cc.Invoke(ctx, MQTTService_SetRetainedMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetRetainedMessage(ctx context.Context, in *GetRetainedMessageRequest, opts ...grpc.CallOption) (*GetRetainedMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRetainedMessageResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetRetainedMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) DeleteRetainedMessage(ctx context.Context, in *DeleteRetainedMessageRequest, opts ...grpc.CallOption) (*DeleteRetainedMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRetainedMessageResponse)
	err := c.cc.Invoke(ctx, MQTTService_DeleteRetainedMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetStatistics(ctx context.Context, in *GetStatisticsRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatisticsResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetStatistics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) GetDeviceMetrics(ctx context.Context, in *GetDeviceMetricsRequest, opts ...grpc.CallOption) (*GetDeviceMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeviceMetricsResponse)
	err := c.cc.Invoke(ctx, MQTTService_GetDeviceMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mQTTServiceClient) HealthCheck(ctx context.Context, in *MQTTHealthCheckRequest, opts ...grpc.CallOption) (*MQTTHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MQTTHealthCheckResponse)
	err := c.cc.Invoke(ctx, MQTTService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MQTTServiceServer is the server API for MQTTService service.
// All implementations must embed UnimplementedMQTTServiceServer
// for forward compatibility.
type MQTTServiceServer interface {
	// ========== 连接管理 ==========
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	GetConnectionStatus(context.Context, *ConnectionStatusRequest) (*ConnectionStatusResponse, error)
	// ========== 消息发布 ==========
	// 发布单条消息
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// 批量发布消息
	PublishBatch(context.Context, *PublishBatchRequest) (*PublishBatchResponse, error)
	// 发布 JSON 消息（自动序列化）
	PublishJSON(context.Context, *PublishJSONRequest) (*PublishResponse, error)
	// ========== 消息订阅 ==========
	// 订阅主题（流式接收消息）
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[MessageResponse]) error
	// 批量订阅多个主题
	SubscribeMultiple(*SubscribeMultipleRequest, grpc.ServerStreamingServer[MessageResponse]) error
	// 取消订阅
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// 获取订阅列表
	ListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error)
	// ========== 设备管理 ==========
	RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error)
	UnregisterDevice(context.Context, *UnregisterDeviceRequest) (*UnregisterDeviceResponse, error)
	ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error)
	GetDeviceInfo(context.Context, *GetDeviceInfoRequest) (*GetDeviceInfoResponse, error)
	UpdateDeviceStatus(context.Context, *UpdateDeviceStatusRequest) (*UpdateDeviceStatusResponse, error)
	// ========== 主题管理 ==========
	GetTopicInfo(context.Context, *GetTopicInfoRequest) (*GetTopicInfoResponse, error)
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	ValidateTopic(context.Context, *ValidateTopicRequest) (*ValidateTopicResponse, error)
	// ========== 保留消息 ==========
	SetRetainedMessage(context.Context, *SetRetainedMessageRequest) (*SetRetainedMessageResponse, error)
	GetRetainedMessage(context.Context, *GetRetainedMessageRequest) (*GetRetainedMessageResponse, error)
	DeleteRetainedMessage(context.Context, *DeleteRetainedMessageRequest) (*DeleteRetainedMessageResponse, error)
	// ========== 统计和监控 ==========
	GetStatistics(context.Context, *GetStatisticsRequest) (*GetStatisticsResponse, error)
	GetDeviceMetrics(context.Context, *GetDeviceMetricsRequest) (*GetDeviceMetricsResponse, error)
	// ========== 健康检查 ==========
	HealthCheck(context.Context, *MQTTHealthCheckRequest) (*MQTTHealthCheckResponse, error)
	mustEmbedUnimplementedMQTTServiceServer()
}

// UnimplementedMQTTServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMQTTServiceServer struct{}

func (UnimplementedMQTTServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedMQTTServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedMQTTServiceServer) GetConnectionStatus(context.Context, *ConnectionStatusRequest) (*ConnectionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectionStatus not implemented")
}
func (UnimplementedMQTTServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedMQTTServiceServer) PublishBatch(context.Context, *PublishBatchRequest) (*PublishBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishBatch not implemented")
}
func (UnimplementedMQTTServiceServer) PublishJSON(context.Context, *PublishJSONRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishJSON not implemented")
}
func (UnimplementedMQTTServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[MessageResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedMQTTServiceServer) SubscribeMultiple(*SubscribeMultipleRequest, grpc.ServerStreamingServer[MessageResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeMultiple not implemented")
}
func (UnimplementedMQTTServiceServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedMQTTServiceServer) ListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubscriptions not implemented")
}
func (UnimplementedMQTTServiceServer) RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedMQTTServiceServer) UnregisterDevice(context.Context, *UnregisterDeviceRequest) (*UnregisterDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterDevice not implemented")
}
func (UnimplementedMQTTServiceServer) ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDevices not implemented")
}
func (UnimplementedMQTTServiceServer) GetDeviceInfo(context.Context, *GetDeviceInfoRequest) (*GetDeviceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceInfo not implemented")
}
func (UnimplementedMQTTServiceServer) UpdateDeviceStatus(context.Context, *UpdateDeviceStatusRequest) (*UpdateDeviceStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeviceStatus not implemented")
}
func (UnimplementedMQTTServiceServer) GetTopicInfo(context.Context, *GetTopicInfoRequest) (*GetTopicInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicInfo not implemented")
}
func (UnimplementedMQTTServiceServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedMQTTServiceServer) ValidateTopic(context.Context, *ValidateTopicRequest) (*ValidateTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateTopic not implemented")
}
func (UnimplementedMQTTServiceServer) SetRetainedMessage(context.Context, *SetRetainedMessageRequest) (*SetRetainedMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRetainedMessage not implemented")
}
func (UnimplementedMQTTServiceServer) GetRetainedMessage(context.Context, *GetRetainedMessageRequest) (*GetRetainedMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRetainedMessage not implemented")
}
func (UnimplementedMQTTServiceServer) DeleteRetainedMessage(context.Context, *DeleteRetainedMessageRequest) (*DeleteRetainedMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRetainedMessage not implemented")
}
func (UnimplementedMQTTServiceServer) GetStatistics(context.Context, *GetStatisticsRequest) (*GetStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatistics not implemented")
}
func (UnimplementedMQTTServiceServer) GetDeviceMetrics(context.Context, *GetDeviceMetricsRequest) (*GetDeviceMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceMetrics not implemented")
}
func (UnimplementedMQTTServiceServer) HealthCheck(context.Context, *MQTTHealthCheckRequest) (*MQTTHealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedMQTTServiceServer) mustEmbedUnimplementedMQTTServiceServer() {}
func (UnimplementedMQTTServiceServer) testEmbeddedByValue()                     {}

// UnsafeMQTTServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MQTTServiceServer will
// result in compilation errors.
type UnsafeMQTTServiceServer interface {
	mustEmbedUnimplementedMQTTServiceServer()
}

func RegisterMQTTServiceServer(s grpc.ServiceRegistrar, srv MQTTServiceServer) {
	// If the following call pancis, it indicates UnimplementedMQTTServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MQTTService_ServiceDesc, srv)
}

func _MQTTService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_Disconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetConnectionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetConnectionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetConnectionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetConnectionStatus(ctx, req.(*ConnectionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_PublishBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).PublishBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_PublishBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).PublishBatch(ctx, req.(*PublishBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_PublishJSON_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishJSONRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).PublishJSON(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_PublishJSON_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).PublishJSON(ctx, req.(*PublishJSONRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MQTTServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, MessageResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MQTTService_SubscribeServer = grpc.ServerStreamingServer[MessageResponse]

func _MQTTService_SubscribeMultiple_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeMultipleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MQTTServiceServer).SubscribeMultiple(m, &grpc.GenericServerStream[SubscribeMultipleRequest, MessageResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MQTTService_SubscribeMultipleServer = grpc.ServerStreamingServer[MessageResponse]

func _MQTTService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).ListSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_ListSubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).ListSubscriptions(ctx, req.(*ListSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_RegisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).RegisterDevice(ctx, req.(*RegisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_UnregisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).UnregisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_UnregisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).UnregisterDevice(ctx, req.(*UnregisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_ListDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDevicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).ListDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_ListDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).ListDevices(ctx, req.(*ListDevicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetDeviceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetDeviceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetDeviceInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetDeviceInfo(ctx, req.(*GetDeviceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_UpdateDeviceStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeviceStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).UpdateDeviceStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_UpdateDeviceStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).UpdateDeviceStatus(ctx, req.(*UpdateDeviceStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetTopicInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetTopicInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetTopicInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetTopicInfo(ctx, req.(*GetTopicInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_ValidateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).ValidateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_ValidateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).ValidateTopic(ctx, req.(*ValidateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_SetRetainedMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRetainedMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).SetRetainedMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_SetRetainedMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).SetRetainedMessage(ctx, req.(*SetRetainedMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetRetainedMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRetainedMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetRetainedMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetRetainedMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetRetainedMessage(ctx, req.(*GetRetainedMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_DeleteRetainedMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRetainedMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).DeleteRetainedMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_DeleteRetainedMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).DeleteRetainedMessage(ctx, req.(*DeleteRetainedMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetStatistics(ctx, req.(*GetStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_GetDeviceMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).GetDeviceMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_GetDeviceMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).GetDeviceMetrics(ctx, req.(*GetDeviceMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MQTTService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MQTTHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MQTTServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MQTTService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MQTTServiceServer).HealthCheck(ctx, req.(*MQTTHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MQTTService_ServiceDesc is the grpc.ServiceDesc for MQTTService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MQTTService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "isa.mqtt.MQTTService",
	HandlerType: (*MQTTServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _MQTTService_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _MQTTService_Disconnect_Handler,
		},
		{
			MethodName: "GetConnectionStatus",
			Handler:    _MQTTService_GetConnectionStatus_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _MQTTService_Publish_Handler,
		},
		{
			MethodName: "PublishBatch",
			Handler:    _MQTTService_PublishBatch_Handler,
		},
		{
			MethodName: "PublishJSON",
			Handler:    _MQTTService_PublishJSON_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _MQTTService_Unsubscribe_Handler,
		},
		{
			MethodName: "ListSubscriptions",
			Handler:    _MQTTService_ListSubscriptions_Handler,
		},
		{
			MethodName: "RegisterDevice",
			Handler:    _MQTTService_RegisterDevice_Handler,
		},
		{
			MethodName: "UnregisterDevice",
			Handler:    _MQTTService_UnregisterDevice_Handler,
		},
		{
			MethodName: "ListDevices",
			Handler:    _MQTTService_ListDevices_Handler,
		},
		{
			MethodName: "GetDeviceInfo",
			Handler:    _MQTTService_GetDeviceInfo_Handler,
		},
		{
			MethodName: "UpdateDeviceStatus",
			Handler:    _MQTTService_UpdateDeviceStatus_Handler,
		},
		{
			MethodName: "GetTopicInfo",
			Handler:    _MQTTService_GetTopicInfo_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _MQTTService_ListTopics_Handler,
		},
		{
			MethodName: "ValidateTopic",
			Handler:    _MQTTService_ValidateTopic_Handler,
		},
		{
			MethodName: "SetRetainedMessage",
			Handler:    _MQTTService_SetRetainedMessage_Handler,
		},
		{
			MethodName: "GetRetainedMessage",
			Handler:    _MQTTService_GetRetainedMessage_Handler,
		},
		{
			MethodName: "DeleteRetainedMessage",
			Handler:    _MQTTService_DeleteRetainedMessage_Handler,
		},
		{
			MethodName: "GetStatistics",
			Handler:    _MQTTService_GetStatistics_Handler,
		},
		{
			MethodName: "GetDeviceMetrics",
			Handler:    _MQTTService_GetDeviceMetrics_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _MQTTService_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _MQTTService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeMultiple",
			Handler:       _MQTTService_SubscribeMultiple_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mqtt_service.proto",
}
