apiVersion: v1
kind: ConfigMap
metadata:
  name: consul-apisix-sync-script
  namespace: isa-cloud-local
  labels:
    app: consul-apisix-sync
    tier: infrastructure
data:
  sync_routes.sh: |
    #!/bin/bash
    # Dynamic Route Synchronization from Consul to APISIX (K8s Version)
    #
    # Designed for Kubernetes environment where services use DNS names instead of IPs

    set -e

    # Colors
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'

    # Configuration
    CONSUL_URL="${CONSUL_URL:-http://consul-ui.isa-cloud-local.svc.cluster.local}"
    APISIX_ADMIN_URL="${APISIX_ADMIN_URL:-http://apisix-admin.isa-cloud-local.svc.cluster.local:9180}"
    ADMIN_KEY="${APISIX_ADMIN_KEY:-edd1c9f034335f136f87ad84b625c8f1}"

    # Functions
    print_success() { echo -e "${GREEN}OK  $1${NC}"; }
    print_error() { echo -e "${RED}ERR $1${NC}"; }
    print_warning() { echo -e "${YELLOW}WARN $1${NC}"; }
    print_info() { echo -e "${BLUE}INFO $1${NC}"; }

    # Get service metadata from Consul
    get_service_meta() {
        local service_name=$1
        local meta=$(curl -s "${CONSUL_URL}/v1/catalog/service/${service_name}" | \
            jq '.[0].ServiceMeta // {}')
        echo "$meta"
    }

    # Create or update route in APISIX
    create_or_update_route() {
        local service_name=$1
        local api_path=$2
        local auth_required=${3:-false}
        local rate_limit=${4:-100}

        local route_name="${service_name}_route"
        # Support both root path and sub-paths using uris array
        # e.g., ["/api/v1/accounts", "/api/v1/accounts/*"]
        local uri_root="${api_path}"
        local uri_pattern="${api_path}/*"

        print_info "Syncing route: $route_name ($uri_root + $uri_pattern -> $service_name)"

        # Check if service needs proxy-rewrite by detecting path mismatch
        # Services like mcp_service expose routes at root (/) but are accessed via /api/v1/mcp
        local needs_rewrite=false
        local meta=$(get_service_meta "$service_name")

        # Check for services that need path rewriting (e.g., mcp_service)
        if [[ "$service_name" == "mcp_service" ]]; then
            needs_rewrite=true
        fi

        # Build plugins
        # SECURITY: Configure CORS_ALLOWED_ORIGINS env var with your actual domains
        # For local development, localhost is acceptable but still explicit
        # WARNING: Wildcard (*) with credentials is dangerous and allows any site to make authenticated requests
        local cors_origins="${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000}"
        local plugins=$(jq -n \
            --arg rate_limit "$rate_limit" \
            --arg cors_origins "$cors_origins" \
            '{
                "cors": {
                    "allow_origins": $cors_origins,
                    "allow_methods": "GET,POST,PUT,PATCH,DELETE,OPTIONS,HEAD",
                    "allow_headers": "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,X-API-Key,X-Request-ID",
                    "expose_headers": "X-Request-ID,X-RateLimit-Limit,X-RateLimit-Remaining,X-RateLimit-Reset",
                    "max_age": 86400,
                    "allow_credentials": true
                },
                "limit-count": {
                    "count": ($rate_limit | tonumber),
                    "time_window": 60,
                    "rejected_code": 429,
                    "rejected_msg": "Rate limit exceeded",
                    "policy": "local"
                },
                "request-id": {
                    "algorithm": "uuid",
                    "include_in_response": true
                },
                "prometheus": {}
            }')

        # Add proxy rewrite if needed
        if [ "$needs_rewrite" = true ]; then
            local rewrite_pattern="^${api_path}(/.*)\\$"
            local rewrite_replacement="\\$1"
            plugins=$(echo "$plugins" | jq --arg pattern "$rewrite_pattern" --arg replacement "$rewrite_replacement" '. + {"proxy-rewrite": {"regex_uri": [$pattern, $replacement]}}')
            print_info "  Added proxy-rewrite: $api_path/* -> /*"
        fi

        # Add auth plugin if required
        if [ "$auth_required" = "true" ]; then
            plugins=$(echo "$plugins" | jq ". + {\"jwt-auth\": {}}")
            print_info "  Added JWT auth requirement"
        fi

        # Create/Update route with uris array (supports both root and wildcard)
        local response=$(curl -s -w "\n%{http_code}" -X PUT \
            "${APISIX_ADMIN_URL}/apisix/admin/routes/${route_name}" \
            -H "X-API-KEY: ${ADMIN_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\
                \"name\": \"${route_name}\",\
                \"uris\": [\"${uri_root}\", \"${uri_pattern}\"],\
                \"priority\": 10,\
                \"status\": 1,\
                \"plugins\": ${plugins},\
                \"upstream\": {\
                    \"type\": \"roundrobin\",\
                    \"service_name\": \"${service_name}\",\
                    \"discovery_type\": \"consul\",\
                    \"scheme\": \"http\",\
                    \"pass_host\": \"pass\",\
                    \"timeout\": {\
                        \"connect\": 6,\
                        \"send\": 6,\
                        \"read\": 10\
                    },\
                    \"keepalive_pool\": {\
                        \"size\": 320,\
                        \"idle_timeout\": 60,\
                        \"requests\": 1000\
                    }\
                }\
            }")

        local http_code=$(echo "$response" | tail -n1)
        if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
            print_success "Route synced: $route_name"
            return 0
        else
            print_error "Failed to sync route: $route_name (HTTP $http_code)"
            echo "$response" | head -n -1
            return 1
        fi
    }

    # Create or update health alias route in APISIX
    create_or_update_health_route() {
        local service_name=$1
        local api_path=$2

        local route_name="${service_name}_health_route"
        local health_uri="${api_path}/health"

        print_info "Syncing health route: $route_name ($health_uri -> $service_name:/health)"

        # SECURITY: Configure CORS_ALLOWED_ORIGINS env var with your actual domains
        local cors_origins="${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000}"
        local plugins=$(jq -n --arg cors_origins "$cors_origins" '{
            "cors": {
                "allow_origins": $cors_origins,
                "allow_methods": "GET,OPTIONS,HEAD",
                "allow_headers": "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,X-API-Key,X-Request-ID",
                "expose_headers": "X-Request-ID",
                "max_age": 86400,
                "allow_credentials": true
            },
            "request-id": {
                "algorithm": "uuid",
                "include_in_response": true
            },
            "prometheus": {},
            "proxy-rewrite": {
                "regex_uri": ["^'"${api_path}"'/health$", "/health"]
            }
        }')

        local response=$(curl -s -w "\n%{http_code}" -X PUT \
            "${APISIX_ADMIN_URL}/apisix/admin/routes/${route_name}" \
            -H "X-API-KEY: ${ADMIN_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\
                \"name\": \"${route_name}\",\
                \"uris\": [\"${health_uri}\"],\
                \"priority\": 20,\
                \"status\": 1,\
                \"plugins\": ${plugins},\
                \"upstream\": {\
                    \"type\": \"roundrobin\",\
                    \"service_name\": \"${service_name}\",\
                    \"discovery_type\": \"consul\",\
                    \"scheme\": \"http\",\
                    \"pass_host\": \"pass\",\
                    \"timeout\": {\
                        \"connect\": 6,\
                        \"send\": 6,\
                        \"read\": 10\
                    }\
                }\
            }")

        local http_code=$(echo "$response" | tail -n1)
        if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
            print_success "Health route synced: $route_name"
            return 0
        else
            print_error "Failed to sync health route: $route_name (HTTP $http_code)"
            echo "$response" | head -n -1
            return 1
        fi
    }

    # Delete route from APISIX
    delete_route() {
        local route_name=$1
        curl -s -X DELETE \
            "${APISIX_ADMIN_URL}/apisix/admin/routes/${route_name}" \
            -H "X-API-KEY: ${ADMIN_KEY}" > /dev/null
        print_success "Deleted route: $route_name"
    }

    # Main sync function
    main() {
        print_info "Starting Consul â†’ APISIX route synchronization (K8s)..."

        # Get all services from Consul
        local services=$(curl -s "${CONSUL_URL}/v1/catalog/services" | jq -r 'keys[]' | grep -v consul || true)

        if [ -z "$services" ]; then
            print_warning "No services found in Consul"
            exit 0
        fi

        # Track processed routes
        local processed_services=()

        # Process each service
        for service_name in $services; do
            # Get service metadata
            local meta=$(get_service_meta "$service_name")
            local api_path=$(echo "$meta" | jq -r '.api_path // .base_path // empty')

            # Skip if no api_path
            if [ -z "$api_path" ] || [ "$api_path" = "null" ]; then
                print_info "Skipping $service_name (no api_path/base_path in metadata)"
                continue
            fi

            local auth_required=$(echo "$meta" | jq -r '.auth_required // "false"')
            local rate_limit=$(echo "$meta" | jq -r '.rate_limit // "100"')

            # Create/Update route
            if create_or_update_route "$service_name" "$api_path" "$auth_required" "$rate_limit"; then
                processed_services+=("${service_name}_route")
            fi
            if create_or_update_health_route "$service_name" "$api_path"; then
                processed_services+=("${service_name}_health_route")
            fi
        done

        print_info "Cleaning up stale routes..."

        # Get all managed routes from APISIX
        local apisix_routes=$(curl -s "${APISIX_ADMIN_URL}/apisix/admin/routes" \
            -H "X-API-KEY: ${ADMIN_KEY}" | jq -r '.list[]?.value.name' | grep '_route$' || true)

        # Delete routes that no longer exist in Consul
        for route_name in $apisix_routes; do
            local found=false
            for processed in "${processed_services[@]}"; do
                if [ "$processed" = "$route_name" ]; then
                    found=true
                    break
                fi
            done

            if [ "$found" = false ]; then
                delete_route "$route_name"
            fi
        done

        local total_routes=$(curl -s "${APISIX_ADMIN_URL}/apisix/admin/routes" \
            -H "X-API-KEY: ${ADMIN_KEY}" | jq -r '.total // 0')
        print_success "Sync complete! Total active routes: ${total_routes}"
    }

    # Run
    main
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: consul-apisix-sync
  namespace: isa-cloud-local
  labels:
    app: consul-apisix-sync
    tier: infrastructure
spec:
  schedule: "*/5 * * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: consul-apisix-sync
        spec:
          restartPolicy: OnFailure
          containers:
            - name: sync
              image: alpine:latest
              command:
                - /bin/sh
                - -c
                - |
                  apk add --no-cache bash curl jq > /dev/null 2>&1
                  bash /scripts/sync_routes.sh
              volumeMounts:
                - name: script
                  mountPath: /scripts
              env:
                - name: CONSUL_URL
                  value: "http://consul-ui.isa-cloud-local.svc.cluster.local"
                - name: APISIX_ADMIN_URL
                  value: "http://apisix-admin.isa-cloud-local.svc.cluster.local:9180"
                - name: APISIX_ADMIN_KEY
                  value: "edd1c9f034335f136f87ad84b625c8f1"
                # SECURITY: Configure allowed CORS origins (comma-separated)
                # For local development, localhost origins are acceptable
                # - name: CORS_ALLOWED_ORIGINS
                #   value: "http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000"
              resources:
                requests:
                  cpu: 50m
                  memory: 64Mi
                limits:
                  cpu: 200m
                  memory: 128Mi
          volumes:
            - name: script
              configMap:
                name: consul-apisix-sync-script
                defaultMode: 0755
